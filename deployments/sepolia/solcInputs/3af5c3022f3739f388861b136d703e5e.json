{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/Auction.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\r\n\r\ninterface IAddressRegistry {\r\n    function marketplace() external view returns (address);\r\n}\r\n\r\ninterface IMarketplace {\r\n    function listedItems(\r\n        address _nftAddress,\r\n        uint256 _tokenId\r\n    ) external view returns (address, uint256 price, bool);\r\n\r\n    function transferNFTtoAuctionWinner(\r\n        address _nftAddress,\r\n        uint256 _tokenId,\r\n        address _winner\r\n    ) external;\r\n}\r\n\r\ncontract Auction is ReentrancyGuard {\r\n    // events\r\n    event AuctionCreated(\r\n        address indexed nft,\r\n        uint256 indexed tokenId,\r\n        uint256 minBid,\r\n        uint256 startTime,\r\n        uint256 endTime\r\n    );\r\n\r\n    event AuctionCanceled(address indexed nft, uint256 indexed tokenId);\r\n\r\n    event UpdatedPlatformFee(uint256 platformFee);\r\n\r\n    event UpdatedPlatformFeeRecipient(address recipient);\r\n    event BidPlaced(\r\n        address indexed nft,\r\n        uint256 indexed tokenId,\r\n        address indexed bidder,\r\n        uint256 bid\r\n    );\r\n\r\n    event BidRefunded(\r\n        address indexed nft,\r\n        uint256 indexed tokenId,\r\n        address indexed bidder,\r\n        uint256 bid\r\n    );\r\n\r\n    event BidWithdrawn(\r\n        address indexed nft,\r\n        uint256 indexed tokenId,\r\n        address indexed bidder,\r\n        uint256 bid\r\n    );\r\n\r\n    event AuctionResulted(\r\n        address oldOwner,\r\n        address indexed nft,\r\n        uint256 indexed tokenId,\r\n        address indexed winner,\r\n        uint256 winingPrice\r\n    );\r\n\r\n    event PauseToggled(bool isPaused);\r\n\r\n    event UpdatedMinBid(\r\n        address indexed nft,\r\n        uint256 indexed tokenId,\r\n        uint256 newMinBid\r\n    );\r\n\r\n    event UpdatedStartTime(\r\n        address indexed nft,\r\n        uint256 indexed tokenId,\r\n        uint256 newStartTime\r\n    );\r\n\r\n    event UpdatedEndTime(\r\n        address indexed nft,\r\n        uint256 indexed tokenId,\r\n        uint256 newEndTime\r\n    );\r\n\r\n    // structs\r\n    struct AuctionStructure {\r\n        address payable owner;\r\n        uint256 minBid;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        bool resulted;\r\n    }\r\n    struct HighestBid {\r\n        address payable bidder;\r\n        uint256 bid;\r\n        uint256 lastBidTime;\r\n    }\r\n\r\n    /// @notice owner of the contract\r\n    address public immutable owner;\r\n\r\n    /// @notice platform fee recipient\r\n    address payable public platformFeeRecipient;\r\n\r\n    /// @notice platform fee percentage\r\n    uint256 public platformFee;\r\n\r\n    /// @notice pause variable for pausing the contract\r\n    bool public isPaused;\r\n\r\n    ///@notice address registry\r\n    IAddressRegistry public addressRegistry;\r\n\r\n    // mappings\r\n    /// @notice nft address -> token id -> auction\r\n    mapping(address => mapping(uint256 => AuctionStructure)) public auctions;\r\n\r\n    /// @notice nft address -> token id -> highest bid\r\n    mapping(address => mapping(uint256 => HighestBid)) public highestBids;\r\n\r\n    // modifiers\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not owner\");\r\n        _;\r\n    }\r\n    modifier whenNotPaused() {\r\n        require(!isPaused, \"contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier isNftOwner(address _nftAddress, uint256 _tokenId) {\r\n        IERC721 nft = IERC721(_nftAddress);\r\n        require(nft.ownerOf(_tokenId) == msg.sender, \"not the token owner\");\r\n        _;\r\n    }\r\n\r\n    modifier auctionNotExist(address _nftAddress, uint256 _tokenId) {\r\n        require(\r\n            auctions[_nftAddress][_tokenId].endTime == 0,\r\n            \"auction already exist\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier auctionExist(address _nftAddress, uint256 _tokenId) {\r\n        require(\r\n            auctions[_nftAddress][_tokenId].endTime > 0,\r\n            \"auction not exist\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(uint256 _platformFee, address payable _feeRecipient) {\r\n        platformFeeRecipient = _feeRecipient;\r\n        platformFee = _platformFee;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n @notice method for creating new auction\r\n @dev only when not paused\r\n @dev only if auction not exist\r\n @dev only if listed\r\n @param _nftAddress nft contract address\r\n @param _tokenId nft token id\r\n @param _minBid minimum bid required\r\n @param _startTime time to start the auction\r\n @param _endTime time to end the auction\r\n*/\r\n    function createAuction(\r\n        address _nftAddress,\r\n        uint256 _tokenId,\r\n        uint256 _minBid,\r\n        uint256 _startTime,\r\n        uint256 _endTime\r\n    )\r\n        external\r\n        whenNotPaused\r\n        isNftOwner(_nftAddress, _tokenId)\r\n        auctionNotExist(_nftAddress, _tokenId)\r\n    {\r\n        IMarketplace marketplace = IMarketplace(addressRegistry.marketplace());\r\n        (, uint256 price, ) = marketplace.listedItems(_nftAddress, _tokenId);\r\n        require(price > 0, \"item is not listed\");\r\n        require(_startTime > _getNow(), \"invalid time start\");\r\n        require(\r\n            _endTime >= _startTime + 300,\r\n            \"end time should be more than 5 mins\"\r\n        );\r\n\r\n        auctions[_nftAddress][_tokenId] = AuctionStructure({\r\n            owner: payable(msg.sender),\r\n            minBid: _minBid,\r\n            startTime: _startTime,\r\n            endTime: _endTime,\r\n            resulted: false\r\n        });\r\n\r\n        emit AuctionCreated(\r\n            _nftAddress,\r\n            _tokenId,\r\n            _minBid,\r\n            _startTime,\r\n            _endTime\r\n        );\r\n    }\r\n\r\n    /**\r\n @notice method for canceling auction\r\n @dev only when not paused\r\n @dev only if exist\r\n @param _nftAddress nft contract address\r\n @param _tokenId nft token id\r\n*/\r\n    function cancelAuction(\r\n        address _nftAddress,\r\n        uint256 _tokenId\r\n    ) external nonReentrant auctionExist(_nftAddress, _tokenId) {\r\n        AuctionStructure memory auction = auctions[_nftAddress][_tokenId];\r\n        require(\r\n            IERC721(_nftAddress).ownerOf(_tokenId) == msg.sender &&\r\n                auction.owner == msg.sender,\r\n            \"not nft owner\"\r\n        );\r\n        require(!auction.resulted, \"auction already resulted\");\r\n        HighestBid memory highestBid = highestBids[_nftAddress][_tokenId];\r\n        if (highestBid.bidder != address(0)) {\r\n            _refundHighestBidder(\r\n                _nftAddress,\r\n                _tokenId,\r\n                highestBid.bidder,\r\n                highestBid.bid\r\n            );\r\n\r\n            // clear highest bidder\r\n            delete (highestBids[_nftAddress][_tokenId]);\r\n        }\r\n\r\n        // clear auction\r\n        delete (auctions[_nftAddress][_tokenId]);\r\n\r\n        emit AuctionCanceled(_nftAddress, _tokenId);\r\n    }\r\n\r\n    /**\r\n @notice method for placing a bid\r\n @dev only when not paused\r\n @dev only if exist\r\n @param _nftAddress nft contract address\r\n @param _tokenId nft token id\r\n*/\r\n    function placeBid(\r\n        address _nftAddress,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        payable\r\n        nonReentrant\r\n        whenNotPaused\r\n        auctionExist(_nftAddress, _tokenId)\r\n    {\r\n        AuctionStructure memory auction = auctions[_nftAddress][_tokenId];\r\n        HighestBid storage highestBid = highestBids[_nftAddress][_tokenId];\r\n        require(\r\n            _getNow() < auction.endTime && _getNow() >= auction.startTime,\r\n            \"out of time\"\r\n        );\r\n        require(!auction.resulted, \"auction has resulted\");\r\n        require(msg.value >= auction.minBid, \"bid is less than minimum bid\");\r\n        require(msg.value > highestBid.bid, \"failed to outBid highest bidder\");\r\n        if (highestBid.bidder != address(0)) {\r\n            _refundHighestBidder(\r\n                _nftAddress,\r\n                _tokenId,\r\n                highestBid.bidder,\r\n                highestBid.bid\r\n            );\r\n        }\r\n\r\n        highestBid.bid = msg.value;\r\n        highestBid.bidder = payable(msg.sender);\r\n        highestBid.lastBidTime = _getNow();\r\n\r\n        emit BidPlaced(_nftAddress, _tokenId, msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n @notice method for withdraw bid by highest bidder after 12 hours\r\n @dev only highest bidder\r\n @param _nftAddress nft contract address\r\n @param _tokenId nft token id\r\n*/\r\n    function withdrawBid(\r\n        address _nftAddress,\r\n        uint256 _tokenId\r\n    ) external nonReentrant {\r\n        HighestBid memory highestBid = highestBids[_nftAddress][_tokenId];\r\n        require(\r\n            msg.sender == highestBid.bidder,\r\n            \"you are not the highest bidder\"\r\n        );\r\n        uint256 _endTime = auctions[_nftAddress][_tokenId].endTime;\r\n        require(\r\n            _getNow() > _endTime && _getNow() - _endTime >= 43200,\r\n            \"can withdraw only after 12 hours auction has ended\"\r\n        );\r\n\r\n        uint256 previousBid = highestBid.bid;\r\n\r\n        //cleaning the existing top bidder\r\n        delete (highestBids[_nftAddress][_tokenId]);\r\n\r\n        // refunding the top bidder\r\n        _refundHighestBidder(\r\n            _nftAddress,\r\n            _tokenId,\r\n            payable(msg.sender),\r\n            previousBid\r\n        );\r\n\r\n        emit BidWithdrawn(_nftAddress, _tokenId, msg.sender, previousBid);\r\n    }\r\n\r\n    /**\r\n @notice method for resulting the finished auction\r\n @dev only nft owner\r\n @dev only if there is a bidder\r\n @param _nftAddress nft contract address\r\n @param _tokenId nft token id\r\n*/\r\n    function resultAuction(\r\n        address _nftAddress,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        nonReentrant\r\n        auctionExist(_nftAddress, _tokenId)\r\n        isNftOwner(_nftAddress, _tokenId)\r\n    {\r\n        AuctionStructure storage auction = auctions[_nftAddress][_tokenId];\r\n        // ensure caller is owner\r\n        require(msg.sender == auction.owner, \"not owner\");\r\n        // ensure auction is ended\r\n        require(_getNow() > auction.endTime, \"auction not ended\");\r\n        // ensure auction has not resulted\r\n        require(!auction.resulted, \"auction already resulted\");\r\n\r\n        // checking highest bidder info\r\n        HighestBid memory highestBid = highestBids[_nftAddress][_tokenId];\r\n        address winner = highestBid.bidder;\r\n        uint256 winningBid = highestBid.bid;\r\n\r\n        // if there is no bids delete the auction\r\n        if (winner == address(0)) {\r\n            delete (auctions[_nftAddress][_tokenId]);\r\n            revert(\"there is no bidder\");\r\n        }\r\n\r\n        // ensure value is higher than minimum bid\r\n        require(winningBid >= auction.minBid, \"amount lower than minimum bid\");\r\n\r\n        auction.resulted = true;\r\n\r\n        delete (highestBids[_nftAddress][_tokenId]);\r\n\r\n        _resultAuction(\r\n            _nftAddress,\r\n            _tokenId,\r\n            auction.owner,\r\n            winner,\r\n            winningBid\r\n        );\r\n    }\r\n\r\n    /**\r\n @notice method for updating minimum bid\r\n @dev only if exist\r\n @dev only auction owner\r\n @param _nftAddress nft contract address\r\n @param _tokenId nft token id\r\n @param _newMinBid new minimum bid\r\n*/\r\n    function updateMinBid(\r\n        address _nftAddress,\r\n        uint256 _tokenId,\r\n        uint256 _newMinBid\r\n    ) external auctionExist(_nftAddress, _tokenId) {\r\n        AuctionStructure storage auction = auctions[_nftAddress][_tokenId];\r\n        require(msg.sender == auction.owner, \"not auction owner\");\r\n        require(!auction.resulted, \"auction already resulted\");\r\n\r\n        HighestBid memory highestBid = highestBids[_nftAddress][_tokenId];\r\n        // check if there is highest bid\r\n        require(\r\n            highestBid.bid == 0,\r\n            \"cannot update the minimum bid if bidder exist\"\r\n        );\r\n\r\n        auction.minBid = _newMinBid;\r\n\r\n        emit UpdatedMinBid(_nftAddress, _tokenId, _newMinBid);\r\n    }\r\n\r\n    /**\r\n @notice method for updating start time\r\n @dev only if exist\r\n @dev only auction owner\r\n @param _nftAddress nft contract address\r\n @param _tokenId nft token id\r\n @param _newStartTime new start time\r\n*/\r\n    function updateStartTime(\r\n        address _nftAddress,\r\n        uint256 _tokenId,\r\n        uint256 _newStartTime\r\n    ) external auctionExist(_nftAddress, _tokenId) {\r\n        AuctionStructure storage auction = auctions[_nftAddress][_tokenId];\r\n        require(msg.sender == auction.owner, \"not auction owner\");\r\n        require(!auction.resulted, \"auction already resulted\");\r\n        require(_newStartTime > 0, \"invalid start time\");\r\n        require(auction.startTime + 60 > _getNow(), \"auction already started\");\r\n        require(\r\n            _newStartTime + 300 < auction.endTime,\r\n            \"auction start time should be less than end time by 5 min\"\r\n        );\r\n\r\n        auction.startTime = _newStartTime;\r\n        emit UpdatedStartTime(_nftAddress, _tokenId, _newStartTime);\r\n    }\r\n\r\n    /**\r\n @notice method for updating end time\r\n @dev only if exist\r\n @dev only auction owner\r\n @param _nftAddress nft contract address\r\n @param _tokenId nft token id\r\n @param _newEndTime new start time\r\n*/\r\n    function updateEndTime(\r\n        address _nftAddress,\r\n        uint256 _tokenId,\r\n        uint256 _newEndTime\r\n    ) external auctionExist(_nftAddress, _tokenId) {\r\n        AuctionStructure storage auction = auctions[_nftAddress][_tokenId];\r\n        require(msg.sender == auction.owner, \"not auction owner\");\r\n        require(!auction.resulted, \"auction already resulted\");\r\n        require(_newEndTime > 0, \"invalid end time\");\r\n        require(_getNow() < auction.endTime, \"auction is ended\");\r\n        require(\r\n            _newEndTime > auction.startTime + 300,\r\n            \"auction end time should be greater than start time by 5 mins\"\r\n        );\r\n        require(\r\n            _newEndTime > _getNow() + 300,\r\n            \"end time should be more than 5 mins\"\r\n        );\r\n\r\n        auction.endTime = _newEndTime;\r\n        emit UpdatedEndTime(_nftAddress, _tokenId, _newEndTime);\r\n    }\r\n\r\n    /// @notice updates the platform fee\r\n    /// @dev only admin\r\n    /// @param _platformFee new platform fee to set\r\n    function updatePlatformFee(uint256 _platformFee) public onlyOwner {\r\n        platformFee = _platformFee;\r\n        emit UpdatedPlatformFee(_platformFee);\r\n    }\r\n\r\n    /// @notice updates the fee recipient\r\n    /// @dev only admin\r\n    /// @param _feeRecipient new fee recipient to receive platform fee\r\n    function updateFeeRecipient(\r\n        address payable _feeRecipient\r\n    ) public onlyOwner {\r\n        require(_feeRecipient != address(0), \"recipient cannot be empty\");\r\n        platformFeeRecipient = _feeRecipient;\r\n        emit UpdatedPlatformFeeRecipient(_feeRecipient);\r\n    }\r\n\r\n    /**\r\n     @notice update address registry\r\n     @dev only admin\r\n     @param _newAddress new address\r\n     */\r\n    function updateAddressRegistry(address _newAddress) public onlyOwner {\r\n        addressRegistry = IAddressRegistry(_newAddress);\r\n    }\r\n\r\n    /**\r\n     @notice Toggling the pause \r\n     @dev Only admin\r\n     */\r\n    function toggleIsPaused() external onlyOwner {\r\n        isPaused = !isPaused;\r\n        emit PauseToggled(isPaused);\r\n    }\r\n\r\n    /// Getter functions\r\n\r\n    /**\r\n     @notice Method for getting all info about the auction\r\n     @param _nftAddress ERC 721 Address\r\n     @param _tokenId Token id of the nft\r\n     */\r\n    function getAuction(\r\n        address _nftAddress,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address payable auctionOwner,\r\n            uint256 minBid,\r\n            uint256 startTime,\r\n            uint256 endTime,\r\n            bool resulted\r\n        )\r\n    {\r\n        AuctionStructure memory auction = auctions[_nftAddress][_tokenId];\r\n\r\n        return (\r\n            auction.owner,\r\n            auction.minBid,\r\n            auction.startTime,\r\n            auction.endTime,\r\n            auction.resulted\r\n        );\r\n    }\r\n\r\n    /**\r\n     @notice Method for getting all info about the highest bidder\r\n     @param _nftAddress ERC 721 Address\r\n     @param _tokenId Token id of the nft\r\n     */\r\n    function getHighestBidder(\r\n        address _nftAddress,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n        view\r\n        returns (address payable bidder, uint256 bid, uint256 lastBidTime)\r\n    {\r\n        HighestBid memory highestBid = highestBids[_nftAddress][_tokenId];\r\n\r\n        return (highestBid.bidder, highestBid.bid, highestBid.lastBidTime);\r\n    }\r\n\r\n    /// @notice getting block timestamp\r\n    function _getNow() internal view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n @notice method for resulting auction\r\n @param _nftAddress ERC 721 Address\r\n @param _tokenId nft token id\r\n @param auctionOwner address of auction owner\r\n @param winner address of winner\r\n @param winningBid bid amount\r\n*/\r\n    function _resultAuction(\r\n        address _nftAddress,\r\n        uint256 _tokenId,\r\n        address auctionOwner,\r\n        address winner,\r\n        uint256 winningBid\r\n    ) private {\r\n        uint256 feeAmount;\r\n\r\n        // sending fee to platform owner\r\n        feeAmount = (winningBid * platformFee) / 1000;\r\n        (bool successFee, ) = platformFeeRecipient.call{value: feeAmount}(\"\");\r\n        require(successFee, \"failed to transfer fee\");\r\n\r\n        // sending royalty fee to owner if collection supports ERC2981 standard\r\n        if (\r\n            IERC165(_nftAddress).supportsInterface(type(IERC2981).interfaceId)\r\n        ) {\r\n            (address receiver, uint256 royaltyFee) = IERC2981(_nftAddress)\r\n                .royaltyInfo(_tokenId, winningBid);\r\n\r\n            (bool royaltySuccess, ) = payable(receiver).call{value: royaltyFee}(\r\n                \"\"\r\n            );\r\n            require(royaltySuccess, \"failed to transfer the royalty\");\r\n            feeAmount += royaltyFee;\r\n        }\r\n\r\n        // sending bid to auction owner\r\n        (bool successTransfer, ) = auctionOwner.call{\r\n            value: winningBid - feeAmount\r\n        }(\"\");\r\n        require(successTransfer, \"failed to transfer the amount to owner\");\r\n\r\n        // sending nft to winner using marketplace function (because marketplace is approved to move token)\r\n        IMarketplace marketplace = IMarketplace(addressRegistry.marketplace());\r\n        marketplace.transferNFTtoAuctionWinner(_nftAddress, _tokenId, winner);\r\n\r\n        emit AuctionResulted(\r\n            msg.sender,\r\n            _nftAddress,\r\n            _tokenId,\r\n            winner,\r\n            winningBid\r\n        );\r\n\r\n        delete (auctions[_nftAddress][_tokenId]);\r\n    }\r\n\r\n    /**\r\n @notice method for refunding highest bidder\r\n @param _nftAddress ERC 721 Address\r\n @param _tokenId nft token id\r\n @param _bidder address of bidder \r\n @param _bid amount\r\n*/\r\n    function _refundHighestBidder(\r\n        address _nftAddress,\r\n        uint256 _tokenId,\r\n        address payable _bidder,\r\n        uint256 _bid\r\n    ) private {\r\n        (bool successRefund, ) = _bidder.call{value: _bid}(\"\");\r\n        require(successRefund, \"failed to refund the highest bidder\");\r\n\r\n        emit BidRefunded(_nftAddress, _tokenId, _bidder, _bid);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}